export const Matrix3 = {
	identity() {
		return [
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1,
		]
	},
	translate(x, y, z) {
		return [
			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1,
		]
	},
	scale(x, y, z) {
		return [
			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1,
		]
	},
	rotateX(deg) {
		const c = Math.cos(deg)
		const s = Math.sin(deg)
		return [
			1,  0, 0, 0,
			0,  c, s, 0,
			0, -s, c, 0,
			0,  0, 0, 1,
		]
	},
	rotateY(deg) {
		const c = Math.cos(deg)
		const s = Math.sin(deg)
		return [
			c, 0, -s, 0,
			0, 1,  0, 0,
			s, 0,  c, 0,
			0, 0,  0, 1,
		]
	},
	rotateZ(deg) {
		const c = Math.cos(deg)
		const s = Math.sin(deg)
		return [
			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1,
		]
	},
	apply(self, other) {
		// NOTE: This code has been autogenerated using generateApply
		return [
			(self[0] * other[0]) + (self[1] * other[4]) + (self[2] * other[8]) + (self[3] * other[12]),
			(self[0] * other[1]) + (self[1] * other[5]) + (self[2] * other[9]) + (self[3] * other[13]),
			(self[0] * other[2]) + (self[1] * other[6]) + (self[2] * other[10]) + (self[3] * other[14]),
			(self[0] * other[3]) + (self[1] * other[7]) + (self[2] * other[11]) + (self[3] * other[15]),
			(self[4] * other[0]) + (self[5] * other[4]) + (self[6] * other[8]) + (self[7] * other[12]),
			(self[4] * other[1]) + (self[5] * other[5]) + (self[6] * other[9]) + (self[7] * other[13]),
			(self[4] * other[2]) + (self[5] * other[6]) + (self[6] * other[10]) + (self[7] * other[14]),
			(self[4] * other[3]) + (self[5] * other[7]) + (self[6] * other[11]) + (self[7] * other[15]),
			(self[8] * other[0]) + (self[9] * other[4]) + (self[10] * other[8]) + (self[11] * other[12]),
			(self[8] * other[1]) + (self[9] * other[5]) + (self[10] * other[9]) + (self[11] * other[13]),
			(self[8] * other[2]) + (self[9] * other[6]) + (self[10] * other[10]) + (self[11] * other[14]),
			(self[8] * other[3]) + (self[9] * other[7]) + (self[10] * other[11]) + (self[11] * other[15]),
			(self[12] * other[0]) + (self[13] * other[4]) + (self[14] * other[8]) + (self[15] * other[12]),
			(self[12] * other[1]) + (self[13] * other[5]) + (self[14] * other[9]) + (self[15] * other[13]),
			(self[12] * other[2]) + (self[13] * other[6]) + (self[14] * other[10]) + (self[15] * other[14]),
			(self[12] * other[3]) + (self[13] * other[7]) + (self[14] * other[11]) + (self[15] * other[15])
		]
	}	,
	applyAll(self, ...others) {
		let res = self
		for (const other of others)
			res = Matrix3.apply(res, other)
		return res
	},
	applyVec(self, vec) {
		const w = vec[3] ?? 1
		return [
			self[0] * vec[0] + self[1] * vec[1] + self[2] * vec[2] + self[3] * w,
			self[4] * vec[0] + self[5] * vec[1] + self[6] * vec[2] + self[7] * w,
			self[8] * vec[0] + self[9] * vec[1] + self[10] * vec[2] + self[11] * w,
			self[12] * vec[0] + self[13] * vec[1] + self[14] * vec[2] + self[15] * w,
		]
	}
}

;(function generateApply() {
	const idx = [
		[0, 1, 2, 3],
		[4, 5, 6, 7],
		[8, 9, 10, 11],
		[12, 13, 14, 15],
	]

	const result = []
	const debug = []
	for (let i = 0; i < 4; i++) {
		for (let j = 0; j < 4; j++) {
			const terms = []
			const debugTerms = []
			for (let e = 0; e < 4; e++) {
				debugTerms.push(
					`(self[${i}, ${e}] * other[${e}, ${j}])`
				)
				terms.push(
					`(self[${idx[i][e]}] * other[${idx[e][j]}])`
				)
			}
			debug.push(`${i} ${j}: ${debugTerms.join(" + ")}`)
			result.push(terms.join(" + "))
		}
	}
	console.log(`DEBUG [\n${debug.join(",\n")}\n]`)
	console.log(`return [\n${result.join(",\n")}\n]`)
})